# Creates a container by using the contents in $(Build.ArtifactStagingDirectory)/packages/... as context.
# Pushes the container to a container registry.
# Replaces the artifact package output with a container.json file that holds the repository and version.
parameters:
- name: Dockerfile
  type: string
  displayName: 'Path to the dockerfile to use.'
- name: PackageName
  type: string
  displayName: 'Name of the subfolder in the artifact package folder.'
- name: Registry
  type: string
  displayName: 'Container registry connection to use.'
- name: Repository
  type: string
  displayName: 'Name of the container repository to use.'
- name: Version
  type: string
  displayName: 'Version that will be used as a tage for the image'

steps:
    # Build and publish docker container.
    - task: Docker@2
      displayName: Build and push docker image
      inputs:
        command: buildAndPush
        dockerfile: ${{ parameters.Dockerfile }}
        buildContext: $(Build.ArtifactStagingDirectory)/packages/${{ parameters.PackageName }}
        containerRegistry: ${{ parameters.Repository }}
        repository: ${{ parameters.Repository }}
        tags: ${{ parameters.Version }}
    
    # Create a file which contains the version (=tag) of the container we just pushed.
    # We put this file in place of the package content, this will allow us to consume the correct container version during CD.
    - task: PowerShell@2
      displayName: Publish container artifacts
      inputs:
        targetType: inline
        script: |
          Remove-Item -Path "$(Build.ArtifactStagingDirectory)/packages/${{ parameters.PackageName }}/*" -Force -Recurse
          $container = @{
            repository = '${{ variables.containerRepository }}'
            version = '${{ variables.containerVersionPrefix }}.$(Build.BuildNumber)'
          }
          $container | ConvertTo-Json | New-Item -Path "$(Build.ArtifactStagingDirectory)/packages/${{ parameters.PackageName }}/" -Name "container.json" -ItemType "file"