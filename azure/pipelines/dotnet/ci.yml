# Builds, tests, packages and publishes a dotnet based solution.
parameters:
- name: Solution
  type: string
  displayName: 'Solution to process.'

- name: BuildConfiguration
  type: string
  default: 'Release'
  displayName: 'Configuration name to build.'
- name: buildPlatform
  type: string
  default: 'Any CPU'
  displayName: 'Platform name to build.'
- name: DotNetSdkVersion
  type: string
  default: ''
  displayName: 'Specifc .NET SDK version to use.'

- name: BeforeTestsSteps
  type: stepList
  default: []
  displayName: 'Optional steps to execute before test execution.'
- name: NoTests
  type: boolean
  default: false
  displayName: 'Whether not to run tests.'
- name: WithPlatinaTestInit
  type: boolean
  default: false
  displayName: 'Whether to run Platina test initialization.'
- name: WithPack
  type: boolean
  default: false
  displayName: 'Whether to run ''dotnet package''.'
- name: WithPublish
  type: boolean
  default: false
  displayName: 'Whether to run ''dotnet publish'' and publish to pipeline artifacts.'
- name: WithRelease
  type: boolean
  default: false
  displayName: 'Whether to push created NuGets to external feed and/or add publish output to pipeline artifacts.'

- name: NuGetConfigPath
  type: string
  default: '.nuget/NuGet.Config'
  displayName: 'Path to NuGet.config file.'
- name: ExternalFeedCredentials
  type: string
  default: ''
  displayName: 'Names of external NuGet feed links. '
- name: WithNuGetCache
  type: boolean
  default: true
  displayName: 'Whether to cache NuGet packages. NUGET_PACKAGES environment variable still needs to be set though.'

steps:
- ${{ if ne(parameters.DotNetSdkVersion, '') }}:
  - task: UseDotNet@2
    displayName: 'Use specific .NET SDK version ${{ parameters.DotNetSdkVersion }}'
    inputs:
      packageType: 'sdk'
      version: ${{ parameters.DotNetSdkVersion }}
      includePreviewVersions: true

- ${{ if ne(parameters.ExternalFeedCredentials, '') }}:
  - task: NuGetAuthenticate@0
    displayName: 'NuGet Authenticate'
    inputs:
      nuGetServiceConnections: ${{ parameters.ExternalFeedCredentials }}

- ${{ if eq(parameters.WithNuGetCache, 'true') }}:
  # As we don't use package lock files, we want to make sure our cache isn't too far behind the dotnet restore.
  # We mainly want to optimize waiting for PR builds.
  - pwsh: echo "##vso[task.setvariable variable=NuGetCacheKey]$(Get-Date -Format yyyyMMdd)"
    displayName: NuGet Package Cache Key
  - task: Cache@2
    displayName: NuGet Package Caching
    inputs:
      key: nuget | "$(Agent.OS)" | "$(NuGetCacheKey)"
      restoreKeys: |
        nuget | "$(Agent.OS)"
      path: $(NUGET_PACKAGES)
    condition: ne(variables.NUGET_PACKAGES, '')
  
- task: DotNetCoreCLI@2
  displayName: 'DotNet Restore'
  inputs: 
    command: 'restore'
    projects: ${{ parameters.Solution }}
    ${{ if parameters.NuGetConfigPath }}:
      feedsToUse: 'config'
      nugetConfigPath: ${{ parameters.NuGetConfigPath }}
      externalFeedCredentials: ${{ parameters.ExternalFeedCredentials }}
      restoreArguments: --locked-mode

- ${{ if and( ne(parameters.NoTests, true), ne(parameters.WithPlatinaTestInit, false) ) }}:
  - task: PowerShell@2
    displayName: 'Platina Begin Test Initialization'
    inputs:
      targetType: 'inline'
      script: |
        &'C:\Program Files\dotnet\dotnet.exe' msbuild /target:BeginPlatinaTestInit '${{ parameters.Solution }}'
        # Ignore msbuild errors because targets might not be present in projects.
        exit 0;

- task: DotNetCoreCLI@2
  displayName: 'DotNet Tool Restore'
  inputs: 
    command: 'custom'
    custom: 'tool'
    arguments: 'restore'

- task: DotNetCoreCLI@2
  displayName: 'DotNet Build'
  inputs:
    command: 'build'
    projects: ${{ parameters.Solution }}
    arguments: '--configuration ${{ parameters.BuildConfiguration }} /p:Platform="${{ parameters.BuildPlatform }}" --no-restore'
  condition: succeededOrFailed()

- ${{ if eq(parameters.WithPack, 'true') }}:
  - task: DotNetCoreCLI@2
    displayName: 'DotNet Pack'
    inputs:
      command: 'pack'
      packagesToPack: ${{ parameters.Solution }}
      versioningScheme: 'off'
      arguments: '--configuration $(BuildConfiguration) --no-restore --no-build'

- ${{ if eq(parameters.WithPublish, 'true') }}:
  - task: DotNetCoreCLI@2
    displayName: 'DotNet Publish'
    inputs:
      command: 'publish'
      projects: ${{ parameters.Solution }}
      arguments: '--configuration ${{ parameters.BuildConfiguration }} --no-restore --no-build --output $(Build.ArtifactStagingDirectory)\packages'
      publishWebProjects: false
      modifyOutputPath: false
      zipAfterPublish: false

- ${{ if ne(parameters.NoTests, 'true') }}:
  - ${{ each step in parameters.BeforeTestsSteps }}:
    - ${{ step }} 
  - ${{ if and( eq(parameters.NoTests, false), ne(parameters.WithPlatinaTestInit, false) ) }}:
    - task: PowerShell@2
      displayName: 'Platina End Test Initialization'
      inputs:
        targetType: 'inline'
        script: |
          &'C:\Program Files\dotnet\dotnet.exe' msbuild /target:EndPlatinaTestInit '${{ parameters.Solution }}'
          # Ignore msbuild errors because targets might not be present in projects.
          exit 0;
  - task: DotNetCoreCLI@2
    displayName: 'DotNet Test'
    inputs:
      command: 'test'
      projects: '**/*[Tt]ests/*.csproj'
      arguments: '--configuration ${{ parameters.BuildConfiguration }} --no-restore --no-build'
    condition: succeededOrFailed()

- ${{ if and( eq(parameters.WithPack, 'true'), eq(parameters.WithRelease, 'true') ) }}:
  # Push NuGets.
  - task: NuGetCommand@2
    displayName: 'NuGet Push'
    inputs:
      command: 'push'
      packagesToPush: '$(Build.ArtifactStagingDirectory)/*.nupkg;$(Build.ArtifactStagingDirectory)/*.snupkg;!$(Build.ArtifactStagingDirectory)/*.symbols.nupkg'
      nuGetFeedType: 'external'
      publishFeedCredentials: $(externalFeedCredentials)

  # The above task does publish the .snupkgs, but Visual Studio can't seem to consume them from the artifact feed yet?
  # Therefore, also publish the .pdb to the SymbolServer of this organization.
  # Users can get rich debugging experience by adding the VSTS symbol server in Visual Studio.
  - task: PublishSymbols@2
    displayName: 'Publish symbols to "local" symbol server too'
    inputs:
      SearchPattern: '**/bin/**/*.pdb'
      SymbolServerType: 'TeamServices'

- ${{ if and( eq(parameters.WithPublish, 'true'), eq(parameters.WithRelease, 'true') ) }}:
  # Publish pipeline artifacts.
  - task: PublishPipelineArtifact@1
    displayName: 'Add publish output to pipeline artifacts'
    inputs:
      path: '$(Build.ArtifactStagingDirectory)\packages'
      artifactName: 'packages'